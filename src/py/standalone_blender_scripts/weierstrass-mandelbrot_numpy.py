"""
PLEASE READ THIS COMMENT BEFORE USING THE CODE!

------------------------------------------
Weierstrass-Mandelbrot Function Terrain Generator for Blender
------------------------------------------

This script generates a procedural terrain mesh using fractal noise
and imports it directly into Blender.

Key Components:
---------------
- Fractal Noise Generation:
    Creates smooth 2D noise patterns for terrain modeling.
- Mesh Conversion:
    Converts the 2D noise map into a 3D mesh grid (x, y, z) suitable for Blender.
- Blender Integration:
    Automatically creates and links a mesh object in the Blender scene.

Modules Used:
-------------
- `numpy`: Matrix operations and numerical tools.
- `bpy`: Blender's Python API for creating objects and meshes.

Usage Instructions:
-------------------
- Update the image path to set a desired texture (see img_path under # TEXTURING)
- Run the script inside Blender's Scripting workspace:
   - Open Blender.
   - Go to the Scripting tab.
   - Load this script.
   - Click Run Script.
"""

import numpy as np
import bpy


def weierstrass_mandelbrot_3d(x, y, D, G, L, gamma, M, n_max):
    """
    Compute the 3D Weierstrass-Mandelbrot function z(x, y).

    Parameters:
        x, y : 2D np.ndarrays
            Meshgrid arrays of spatial coordinates.
        D : float
            Fractal dimension (typically between 2 and 3).
        G : float
            Amplitude roughness coefficient.
        L : float
            Transverse width of the profile.
        gamma : float
            Frequency scaling factor (typically > 1).
        M : int
            Number of ridges (azimuthal angles).
        n_max : int
            Upper cutoff frequency index.

    Returns:
        z : 2D np.ndarray
            The height field generated by the WM function.
    """
    A = L * (G / L) ** (D - 2) * (np.log(gamma) / M) ** 0.5

    z = np.zeros_like(x)

    for m in range(1, M + 1):
        theta_m = np.arctan2(y, x) - np.pi * m / M
        phi_mn = np.random.uniform(
            0, 2 * np.pi, size=n_max + 1)  # random phase per n

        for n in range(n_max + 1):
            gamma_n = gamma ** n
            r = np.sqrt(x ** 2 + y ** 2)
            term = (
                np.cos(phi_mn[n]) -
                np.cos(
                    2 * np.pi * gamma_n * r / L *
                    np.cos(theta_m) + phi_mn[n]
                )
            )
            z += gamma ** ((D - 3) * n) * term

    z *= A
    return z


def grid_to_xyz(z_grid, start_coordinate, end_coordinate):
    """
    Convert a 2D grid of z-values into a (N*M)x3 array of [x, y, z] coordinates,
    where x and y are linearly spaced between start_coordinate and end_coordinate.

    Parameters:
    - z_grid: 2D NumPy array of shape (N, M), representing z-values over a grid.
    - start_coordinate: float, the starting coordinate value for both x and y axes.
    - end_coordinate: float, the ending coordinate value for both x and y axes.

    Returns:
    - xyz: NumPy array of shape (N*M, 3), where each row is [x, y, z].
    """

    # Get the number of rows (N) and columns (M) from the shape of the z_grid
    nrows, ncols = z_grid.shape

    # Create a 1D array of x coordinates (length M) evenly spaced from start to end
    x = np.linspace(start_coordinate, end_coordinate, ncols)

    # Create a 1D array of y coordinates (length N) evenly spaced from start to end
    y = np.linspace(start_coordinate, end_coordinate, nrows)

    # Create a 2D meshgrid from the x and y coordinate vectors
    # xx has shape (N, M), each row is a copy of x
    # yy has shape (N, M), each column is a copy of y
    xx, yy = np.meshgrid(x, y)

    # Flatten xx, yy, and z_grid into 1D arrays (length N*M each),
    # and stack them as columns to form an (N*M)x3 array of [x, y, z]
    xyz = np.column_stack((xx.ravel(), yy.ravel(), z_grid.ravel()))

    return xyz


def generate_faces_from_grid(n_row, n_col):
    """
    Generate triangle face indices for a (n_row x n_col) grid of vertices,
    assuming the vertices are flattened row-major (C-style) to a 1D array.

    Returns:
    - faces: (2 * (n_row - 1) * (n_col - 1), 3) int NumPy array of triangle indices
    """
    # Create 2D grid of top-left corner indices for each quad
    i = np.arange(n_row - 1)
    j = np.arange(n_col - 1)
    ii, jj = np.meshgrid(i, j, indexing='ij')  # shape: (n_row-1, n_col-1)

    # Flatten grid of cell indices
    ii = ii.ravel()
    jj = jj.ravel()

    # Convert 2D grid indices to flat indices in the 1D vertex array
    top_left = ii + jj * n_col
    bottom_left = ii + (jj + 1) * n_col
    top_right = (ii + 1) + jj * n_col
    bottom_right = (ii + 1) + (jj + 1) * n_col

    # Create two triangles per grid cell
    tri1 = np.stack([top_left, bottom_left, top_right], axis=1)
    tri2 = np.stack([top_right, bottom_left, bottom_right], axis=1)

    # Concatenate both triangles
    faces = np.concatenate([tri1, tri2], axis=0)
    return faces


if __name__ == '__main__':  # example

    size = 400
    res = 2000
    random_seed = 123

    np.random.seed(random_seed)

    # Create meshgrid
    x_vals = np.linspace(0, size, res)
    y_vals = np.linspace(0, size, res)
    x, y = np.meshgrid(x_vals, y_vals)

    # Example parameters
    D = 2.5
    G = 1e-1
    L = 100.0
    gamma = 1.5
    M = 10
    n_max = 10

    # Compute WM surfaces
    z1 = weierstrass_mandelbrot_3d(
        x=x, y=y, D=2.2,  G=1e-6, L=L, gamma=gamma, M=16, n_max=n_max)
    z2 = weierstrass_mandelbrot_3d(
        x=x, y=y, D=2.45, G=8e-8, L=L, gamma=gamma, M=32, n_max=n_max)
    z3 = weierstrass_mandelbrot_3d(
        x=x, y=y, D=2.45, G=1e-8, L=L, gamma=gamma, M=64, n_max=n_max)

    # Compute Hadamard product
    z = z1 * z2 * z3

    # Normalize to [0,1]
    z = np.interp(z, (z.min(), z.max()), (0, 1))

    # Generate mesh data
    vertices = grid_to_xyz(z, start_coordinate=-12, end_coordinate=12).tolist()
    faces = generate_faces_from_grid(res, res)

    # Create mesh and object
    wm_mesh = bpy.data.meshes.new("wm_mesh")
    wm_mesh.from_pydata(vertices, [], faces)
    wm_mesh.update()

    # Add vertex colors
    color_layer = wm_mesh.vertex_colors.new(name="Col")

    # Normalize z values for color mapping
    z_values = np.array([v[2] for v in vertices])
    z_min, z_max = z_values.min(), z_values.max()

    def lerp(a, b, t):
        return tuple(a[i] + (b[i] - a[i]) * t for i in range(4))

    def height_to_color(z):
        norm_z = (z - z_min) / (z_max - z_min)

        # Define key color points (RGBA)
        white = (0.9, 0.9, 0.9, 1.0)
        gray = (0.3, 0.3, 0.3, 1.0)
        green = (0.196, 0.231, 0.011, 1.0)
        brown = (0.5, 0.37, 0.235, 1.0)

        if norm_z >= 0.4:
            # White to Gray
            t = (norm_z - 0.4) / 0.6
            return lerp(gray, white, t)
        elif norm_z >= 0.1:
            # Gray to Brown
            t = (norm_z - 0.1) / 0.3
            return lerp(brown, gray, t)
        elif norm_z >= 0.0:
            # Brown to Green
            t = norm_z / 0.1
            return lerp(green, brown, t)
        else:
            return green  # fallback for any value below z_min

    # Create object and collection
    wm_terrain = bpy.data.objects.new("wm_terrain", wm_mesh)
    terrain_collection = bpy.data.collections.new("terrain_collection")
    bpy.context.scene.collection.children.link(terrain_collection)
    terrain_collection.objects.link(wm_terrain)

    # Assign colors to each face's loops
    for poly in wm_mesh.polygons:
        for loop_idx in poly.loop_indices:
            vert_idx = wm_mesh.loops[loop_idx].vertex_index
            ze = vertices[vert_idx][2]
            color_layer.data[loop_idx].color = height_to_color(ze)

    # Assign material that uses vertex color
    mat = bpy.data.materials.new(name="TerrainMaterial")
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links

    # Clear default nodes
    for node in nodes:
        nodes.remove(node)

    # Add new nodes
    output_node = nodes.new(type='ShaderNodeOutputMaterial')
    diffuse_node = nodes.new(type='ShaderNodeBsdfDiffuse')
    vc_node = nodes.new(type='ShaderNodeVertexColor')
    vc_node.layer_name = "Col"

    # Connect nodes
    links.new(vc_node.outputs['Color'], diffuse_node.inputs['Color'])
    links.new(diffuse_node.outputs['BSDF'], output_node.inputs['Surface'])

    # Assign material
    wm_mesh.materials.append(mat)
    wm_terrain.data.materials.append(mat)

    # Plot
    # """
    import matplotlib.pyplot as plt

    plt.imshow(z, cmap='gray', interpolation='lanczos')  # height map
    plt.colorbar()
    plt.show()
    # """
