"""
Generates a terrain heightmap by blending Perlin noise, multiple Weierstrassâ€“Mandelbrot layers,
and an optional trend. Saves output as .npy and visualizes in 2D/3D.

- Adjustable params: resolution, Perlin scale, WM layers, trend, blending alpha.
- Uses GPU (CUDA) if available.
- Output: NumPy array (heightmap).
"""

import torch
import math
import numpy as np


def weierstrass_mandelbrot_3d_torch(x, y, D, G, L, gamma, M, n_max, device='cuda'):
    """
    Compute the 3D Weierstrass-Mandelbrot function z(x, y) using PyTorch on the GPU.

    Parameters:
        x, y : 2D np.ndarrays
            Meshgrid arrays of spatial coordinates.
        D : float
            Fractal dimension (typically between 2 and 3).
        G : float
            Amplitude roughness coefficient.
        L : float
            Transverse width of the profile.
        gamma : float
            Frequency scaling factor (typically > 1).
        M : int
            Number of ridges (azimuthal angles).
        n_max : int
            Upper cutoff frequency index.
        device: str
            Device to use. Defaults to 'cude'.

    Returns:
        z : 2D np.ndarray
            The height field generated by the WM function.
    """
    x = torch.tensor(x, dtype=torch.float32, device=device)
    y = torch.tensor(y, dtype=torch.float32, device=device)
    A = L * (G / L) ** (D - 2) * (torch.log(torch.tensor(gamma)) / M) ** 0.5

    z = torch.zeros_like(x)

    r = torch.sqrt(x ** 2 + y ** 2)
    for m in range(1, M + 1):
        theta_m = torch.atan2(y, x) - torch.pi * m / M
        phi_mn = torch.rand(n_max + 1, device=device, generator=gen) * 2 * torch.pi

        for n in range(n_max + 1):
            gamma_n = gamma ** n
            term = (
                torch.cos(phi_mn[n]) -
                torch.cos(2 * torch.pi * gamma_n * r / L * torch.cos(theta_m) + phi_mn[n])
            )
            z += gamma ** ((D - 3) * n) * term

    return (A * z).cpu().numpy()


def default_interpolant(t):
    return t * t * t * (t * (t * 6 - 15) + 10)


def generate_perlin_noise_2d_torch(shape, res, tileable=(False, False), interpolant=default_interpolant, device='cpu'):
    """
    Generate 2D Perlin noise using PyTorch.

    Args:
        shape: Tuple[int, int], output shape (must be multiple of res).
        res: Tuple[int, int], number of periods (must divide shape).
        tileable: Tuple[bool, bool], whether noise is tileable in each axis.
        interpolant: Callable, interpolation function.
        device: 'cpu' or 'cuda'.

    Returns:
        torch.Tensor of shape `shape`, with values in [-1, 1].
    """
    if shape[0] % res[0] != 0 or shape[1] % res[1] != 0:
        raise ValueError("Shape must be multiple of res")

    d = (shape[0] // res[0], shape[1] // res[1])
    delta = (res[0] / shape[0], res[1] / shape[1])

    # Grid of coordinates
    grid_y, grid_x = torch.meshgrid(
        torch.linspace(0, res[0], steps=shape[0], device=device, dtype=torch.float32, requires_grad=False) % 1,
        torch.linspace(0, res[1], steps=shape[1], device=device, dtype=torch.float32, requires_grad=False) % 1,
        indexing='xy'
    )
    grid = torch.stack((grid_x, grid_y), dim=-1)

    # Generate random gradients
    angles = 2 * math.pi * torch.rand(res[0] + 1, res[1] + 1, device=device, generator=gen)
    gradients = torch.stack((torch.cos(angles), torch.sin(angles)), dim=-1)

    if tileable[0]:
        gradients[-1, :] = gradients[0, :]
    if tileable[1]:
        gradients[:, -1] = gradients[:, 0]

    gradients = gradients.repeat_interleave(d[0], dim=0).repeat_interleave(d[1], dim=1)

    g00 = gradients[:-d[0], :-d[1]]
    g10 = gradients[d[0]:, :-d[1]]
    g01 = gradients[:-d[0], d[1]:]
    g11 = gradients[d[0]:, d[1]:]

    # Compute dot products (ramps)
    dot = lambda grad, offset: (grid + offset).mul(grad).sum(dim=2)

    n00 = dot(g00, torch.zeros_like(grid))
    n10 = dot(g10, torch.tensor([-1, 0], device=device))
    n01 = dot(g01, torch.tensor([0, -1], device=device))
    n11 = dot(g11, torch.tensor([-1, -1], device=device))

    # Interpolate
    t = interpolant(grid)
    t_x = t[..., 0]
    t_y = t[..., 1]

    n0 = n00 * (1 - t_x) + t_x * n10
    n1 = n01 * (1 - t_x) + t_x * n11
    return torch.sqrt(torch.tensor(2.0, device=device)) * ((1 - t_y) * n0 + t_y * n1)


def generate_combined_noise(
    res: int,
    perlin_res=(4, 4),
    scale_wm=600,
    wm_layers=None,
    trend=None,
    alpha=0.5,
    device='cuda'
):
    """
    Generate combined Perlin + multi-layer WM noise with optional trend.

    Args:
        res: int, resolution (res x res grid).
        perlin_res: tuple of ints, Perlin noise resolution.
        scale_wm: int, W-M noise scale
        wm_layers: list of dicts, each dict has WM layer params: D, G, L, gamma, M, n_max.
        trend: ndarray of shape (res, res), trend to add.
        alpha: float in [0,1], blending factor for Perlin noise.
        device: 'cuda' or 'cpu'
    Returns:
        np.ndarray: Combined normalized noise array.
    """


    if wm_layers is None:
        wm_layers = []

    # === Meshgrid ===
    x_vals = np.linspace(0, scale_wm, res)
    y_vals = np.linspace(0, scale_wm, res)
    x, y = np.meshgrid(x_vals, y_vals)

    # === Generate WM Noise Product ===
    z = np.ones_like(x)
    for layer in wm_layers:
        z_layer = weierstrass_mandelbrot_3d_torch(
            x=x,
            y=y,
            D=layer['D'],
            G=layer['G'],
            L=layer['L'],
            gamma=layer['gamma'],
            M=layer['M'],
            n_max=layer['n_max'],
            device=device
        )
        z *= z_layer

    # Normalize WM to [0, 1]
    z = np.interp(z, (z.min(), z.max()), (0, 1))

    # === Add trend ===
    if trend is not None:
        z += trend
        z = np.interp(z, (z.min(), z.max()), (0, 1))

    # === Generate Perlin Noise ===
    perlin = generate_perlin_noise_2d_torch(
        shape=(res, res),
        res=perlin_res,
        tileable=(True, True),
        device=device
    ).cpu().numpy()
    perlin = np.interp(perlin, (perlin.min(), perlin.max()), (0, 1))

    # === Blend Perlin and WM ===
    combined = (1 - alpha) * z + alpha * perlin

    return combined


if __name__ == '__main__':
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D

    # === Parameters ===
    res = 2000
    perlin_res = (20, 20)
    scale_wm = 50
    alpha = 0.3  # blending factor, describes the magnitude of Perlin Noise (can be negative)
    seed = 1738

    gen = torch.Generator(device='cuda' if torch.cuda.is_available() else 'cpu').manual_seed(seed)  # seed random

    # === Trend ===
    size = 600
    x_trend = torch.linspace(0, size, res)
    y_trend = torch.linspace(0, size, res)
    X_trend, Y_trend = torch.meshgrid(x_trend, y_trend, indexing='xy')
    trend = (0.3 * torch.sin(X_trend * 4 / size)).cpu().numpy()

    # === WM Layers ===
    wm_layers = [
        {'D': 2.2, 'G': 1e-6, 'L': 100.0, 'gamma': 1.5, 'M': 16, 'n_max': 10},
        {'D': 2.45, 'G': 8e-8, 'L': 100.0, 'gamma': 1.5, 'M': 32, 'n_max': 10},
        {'D': 2.45, 'G': 1e-8, 'L': 100.0, 'gamma': 1.5, 'M': 64, 'n_max': 10},
    ]

    noise = generate_combined_noise(
        res=res,
        scale_wm=scale_wm,
        perlin_res=perlin_res,
        wm_layers=wm_layers,
        trend=trend,
        alpha=alpha,
        device='cuda' if torch.cuda.is_available() else 'cpu'
    )

    # === Save as .npy ===
    np.save(r"C:\Users\79140\PycharmProjects\procedural-terrain-generation\data\combined_terrain.npy", noise)

    # === 2D visualization ===
    plt.imshow(noise, cmap='gray')
    plt.colorbar()
    plt.title("Combined WM + Perlin Noise (2D)")
    plt.show()

    # === 3D visualization ===
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')

    # Reduce resolution for faster rendering
    step = res // 200  # downsample factor
    X, Y = np.meshgrid(np.arange(0, res, step), np.arange(0, res, step))
    Z = noise[::step, ::step]

    ax.plot_surface(X, Y, Z, cmap='terrain', linewidth=0, antialiased=True)
    ax.set_title("3D Terrain Surface")
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Height")
    plt.show()


