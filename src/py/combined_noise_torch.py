import torch
import math
import numpy as np


def weierstrass_mandelbrot_3d_torch(x, y, D, G, L, gamma, M, n_max, device='cuda'):
    """
    Compute the 3D Weierstrass-Mandelbrot function z(x, y) using PyTorch on the GPU.

    Parameters:
        x, y : 2D np.ndarrays
            Meshgrid arrays of spatial coordinates.
        D : float
            Fractal dimension (typically between 2 and 3).
        G : float
            Amplitude roughness coefficient.
        L : float
            Transverse width of the profile.
        gamma : float
            Frequency scaling factor (typically > 1).
        M : int
            Number of ridges (azimuthal angles).
        n_max : int
            Upper cutoff frequency index.
        device: str
            Device to use. Defaults to 'cude'.

    Returns:
        z : 2D np.ndarray
            The height field generated by the WM function.
    """
    x = torch.tensor(x, dtype=torch.float32, device=device)
    y = torch.tensor(y, dtype=torch.float32, device=device)
    A = L * (G / L) ** (D - 2) * (torch.log(torch.tensor(gamma)) / M) ** 0.5

    z = torch.zeros_like(x)

    r = torch.sqrt(x ** 2 + y ** 2)
    for m in range(1, M + 1):
        theta_m = torch.atan2(y, x) - torch.pi * m / M
        phi_mn = torch.rand(n_max + 1, device=device) * 2 * torch.pi

        for n in range(n_max + 1):
            gamma_n = gamma ** n
            term = (
                torch.cos(phi_mn[n]) -
                torch.cos(2 * torch.pi * gamma_n * r / L * torch.cos(theta_m) + phi_mn[n])
            )
            z += gamma ** ((D - 3) * n) * term

    return (A * z).cpu().numpy()


def default_interpolant(t):
    return t * t * t * (t * (t * 6 - 15) + 10)


def generate_perlin_noise_2d_torch(shape, res, tileable=(False, False), interpolant=default_interpolant, device='cpu'):
    """
    Generate 2D Perlin noise using PyTorch.

    Args:
        shape: Tuple[int, int], output shape (must be multiple of res).
        res: Tuple[int, int], number of periods (must divide shape).
        tileable: Tuple[bool, bool], whether noise is tileable in each axis.
        interpolant: Callable, interpolation function.
        device: 'cpu' or 'cuda'.

    Returns:
        torch.Tensor of shape `shape`, with values in [-1, 1].
    """
    if shape[0] % res[0] != 0 or shape[1] % res[1] != 0:
        raise ValueError("Shape must be multiple of res")

    d = (shape[0] // res[0], shape[1] // res[1])
    delta = (res[0] / shape[0], res[1] / shape[1])

    # Grid of coordinates
    grid_y, grid_x = torch.meshgrid(
        torch.linspace(0, res[0], steps=shape[0], device=device, dtype=torch.float32, requires_grad=False) % 1,
        torch.linspace(0, res[1], steps=shape[1], device=device, dtype=torch.float32, requires_grad=False) % 1,
        indexing='xy'
    )
    grid = torch.stack((grid_x, grid_y), dim=-1)

    # Generate random gradients
    angles = 2 * math.pi * torch.rand(res[0] + 1, res[1] + 1, device=device)
    gradients = torch.stack((torch.cos(angles), torch.sin(angles)), dim=-1)

    if tileable[0]:
        gradients[-1, :] = gradients[0, :]
    if tileable[1]:
        gradients[:, -1] = gradients[:, 0]

    gradients = gradients.repeat_interleave(d[0], dim=0).repeat_interleave(d[1], dim=1)

    g00 = gradients[:-d[0], :-d[1]]
    g10 = gradients[d[0]:, :-d[1]]
    g01 = gradients[:-d[0], d[1]:]
    g11 = gradients[d[0]:, d[1]:]

    # Compute dot products (ramps)
    dot = lambda grad, offset: (grid + offset).mul(grad).sum(dim=2)

    n00 = dot(g00, torch.zeros_like(grid))
    n10 = dot(g10, torch.tensor([-1, 0], device=device))
    n01 = dot(g01, torch.tensor([0, -1], device=device))
    n11 = dot(g11, torch.tensor([-1, -1], device=device))

    # Interpolate
    t = interpolant(grid)
    t_x = t[..., 0]
    t_y = t[..., 1]

    n0 = n00 * (1 - t_x) + t_x * n10
    n1 = n01 * (1 - t_x) + t_x * n11
    return torch.sqrt(torch.tensor(2.0, device=device)) * ((1 - t_y) * n0 + t_y * n1)


if __name__ == '__main__':
    import matplotlib.pyplot as plt

    size = 600
    res = 2000
    random_seed = 123

    torch.manual_seed(random_seed)
    if torch.cuda.is_available():
        torch.cuda.manual_seed_all(random_seed)

    # Create meshgrid
    x_vals = np.linspace(0, size, res)
    y_vals = np.linspace(0, size, res)
    x, y = np.meshgrid(x_vals, y_vals)

    # Example parameters
    D = 2.5
    G = 1e-1
    L = 100.0
    gamma = 1.5
    M = 10
    n_max = 10

    perlin = generate_perlin_noise_2d_torch(
        shape=(2000, 2000),
        res=(4, 4),
        tileable=(True, True),
        device='cuda' if torch.cuda.is_available() else 'cpu'
    )

    # Compute WM surfaces
    z1 = weierstrass_mandelbrot_3d_torch(
        x=x, y=y, D=2.2, G=1e-6, L=L, gamma=gamma, M=16, n_max=n_max)
    z2 = weierstrass_mandelbrot_3d_torch(
        x=x, y=y, D=2.45, G=8e-8, L=L, gamma=gamma, M=32, n_max=n_max)
    z3 = weierstrass_mandelbrot_3d_torch(
        x=x, y=y, D=2.45, G=1e-8, L=L, gamma=gamma, M=64, n_max=n_max)

    # Compute Hadamard product
    z = z1 * z2 * z3

    # DEFINE TREND
    x_trend = torch.linspace(0, size, res)
    y_trend = torch.linspace(0, size, res)
    X_trend, Y_trend = torch.meshgrid(x_trend, y_trend, indexing='xy')
    trend = (0.3 * torch.sin(X_trend * 4 / size)).cpu().numpy()

    # Normalize to [0,1]
    z = np.interp(z, (z.min(), z.max()), (0, 1))

    z += trend

    noise = z + perlin.cpu().numpy()

    # Save as .npy
    np.save(r"C:\Users\79140\PycharmProjects\procedural-terrain-generation\data\combined_terrain.npy", noise)

    plt.imshow(noise, cmap='gray')
    plt.colorbar()
    plt.title("Perlin + W-M Noise (Torch Accelerated)")
    plt.show()
