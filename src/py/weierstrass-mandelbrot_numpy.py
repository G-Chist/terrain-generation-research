"""
PLEASE READ THIS COMMENT BEFORE USING THE CODE!

------------------------------------------
Weierstrass-Mandelbrot Function Terrain Generator for Blender
------------------------------------------

This script generates a procedural terrain mesh using fractal noise
and imports it directly into Blender.

Key Components:
---------------
- Fractal Noise Generation:
    Creates smooth 2D noise patterns for terrain modeling.
- Mesh Conversion:
    Converts the 2D noise map into a 3D mesh grid (x, y, z) suitable for Blender.
- Blender Integration:
    Automatically creates and links a mesh object in the Blender scene.

Modules Used:
-------------
- `numpy`: Matrix operations and numerical tools.
- `bpy`: Blender's Python API for creating objects and meshes.

Usage Instructions:
-------------------
- Update the image path to set a desired texture (see img_path under # TEXTURING)
- Run the script inside Blender's Scripting workspace:
   - Open Blender.
   - Go to the Scripting tab.
   - Load this script.
   - Click Run Script.
"""

import numpy as np
import bpy


def weierstrass_mandelbrot_3d(x, y, D, G, L, gamma, M, n_max):
    """
    Compute the 3D Weierstrass-Mandelbrot function z(x, y).

    Parameters:
        x, y : 2D np.ndarrays
            Meshgrid arrays of spatial coordinates.
        D : float
            Fractal dimension (typically between 2 and 3).
        G : float
            Amplitude roughness coefficient.
        L : float
            Transverse width of the profile.
        gamma : float
            Frequency scaling factor (typically > 1).
        M : int
            Number of ridges (azimuthal angles).
        n_max : int
            Upper cutoff frequency index.

    Returns:
        z : 2D np.ndarray
            The height field generated by the WM function.
    """
    A = L * (G / L) ** (D - 2) * (np.log(gamma) / M) ** 0.5

    z = np.zeros_like(x)

    for m in range(1, M + 1):
        theta_m = np.arctan2(y, x) - np.pi * m / M
        phi_mn = np.random.uniform(0, 2 * np.pi, size=n_max + 1)  # random phase per n

        for n in range(n_max + 1):
            gamma_n = gamma ** n
            r = np.sqrt(x ** 2 + y ** 2)
            term = (
                    np.cos(phi_mn[n]) -
                    np.cos(
                        2 * np.pi * gamma_n * r / L *
                        np.cos(theta_m) + phi_mn[n]
                    )
            )
            z += gamma ** ((D - 3) * n) * term

    z *= A
    return z


def grid_to_xyz(z_grid, start_coordinate, end_coordinate):
    """
    Convert a 2D grid of z-values into a (N*M)x3 array of [x, y, z] coordinates,
    where x and y are linearly spaced between start_coordinate and end_coordinate.

    Parameters:
    - z_grid: 2D NumPy array of shape (N, M), representing z-values over a grid.
    - start_coordinate: float, the starting coordinate value for both x and y axes.
    - end_coordinate: float, the ending coordinate value for both x and y axes.

    Returns:
    - xyz: NumPy array of shape (N*M, 3), where each row is [x, y, z].
    """

    # Get the number of rows (N) and columns (M) from the shape of the z_grid
    nrows, ncols = z_grid.shape

    # Create a 1D array of x coordinates (length M) evenly spaced from start to end
    x = np.linspace(start_coordinate, end_coordinate, ncols)

    # Create a 1D array of y coordinates (length N) evenly spaced from start to end
    y = np.linspace(start_coordinate, end_coordinate, nrows)

    # Create a 2D meshgrid from the x and y coordinate vectors
    # xx has shape (N, M), each row is a copy of x
    # yy has shape (N, M), each column is a copy of y
    xx, yy = np.meshgrid(x, y)

    # Flatten xx, yy, and z_grid into 1D arrays (length N*M each),
    # and stack them as columns to form an (N*M)x3 array of [x, y, z]
    xyz = np.column_stack((xx.ravel(), yy.ravel(), z_grid.ravel()))

    return xyz


def generate_faces_from_grid(n_row, n_col):
    """
    Generate triangle face indices for a (n_row x n_col) grid of vertices,
    assuming the vertices are flattened row-major (C-style) to a 1D array.

    Returns:
    - faces: (2 * (n_row - 1) * (n_col - 1), 3) int NumPy array of triangle indices
    """
    # Create 2D grid of top-left corner indices for each quad
    i = np.arange(n_row - 1)
    j = np.arange(n_col - 1)
    ii, jj = np.meshgrid(i, j, indexing='ij')  # shape: (n_row-1, n_col-1)

    # Flatten grid of cell indices
    ii = ii.ravel()
    jj = jj.ravel()

    # Convert 2D grid indices to flat indices in the 1D vertex array
    top_left = ii + jj * n_col
    bottom_left = ii + (jj + 1) * n_col
    top_right = (ii + 1) + jj * n_col
    bottom_right = (ii + 1) + (jj + 1) * n_col

    # Create two triangles per grid cell
    tri1 = np.stack([top_left, bottom_left, top_right], axis=1)
    tri2 = np.stack([top_right, bottom_left, bottom_right], axis=1)

    # Concatenate both triangles
    faces = np.concatenate([tri1, tri2], axis=0)
    return faces


if __name__ == '__main__':  # example
    # import matplotlib.pyplot as plt
    
    size = 128
    res = 500

    # Create meshgrid
    x_vals = np.linspace(0, size, res)
    y_vals = np.linspace(0, size, res)
    x, y = np.meshgrid(x_vals, y_vals)

    # Example parameters
    D = 2.5
    G = 1e-1
    L = 100.0
    gamma = 1.5
    M = 10
    n_max = 10

    # Compute WM surfaces
    z1 = weierstrass_mandelbrot_3d(x=x, y=y, D=2.2,  G=1e-6, L=L, gamma=gamma, M=16, n_max=n_max)
    z2 = weierstrass_mandelbrot_3d(x=x, y=y, D=2.45, G=8e-8, L=L, gamma=gamma, M=32, n_max=n_max)
    z3 = weierstrass_mandelbrot_3d(x=x, y=y, D=2.45, G=1e-8, L=L, gamma=gamma, M=64, n_max=n_max)

    # Compute Hadamard product
    z = z1 * z2 * z3

    # Normalize to [0,1]
    z = np.interp(z, (z.min(), z.max()), (0, 1))

    # Generate mesh data
    vertices = grid_to_xyz(z, start_coordinate=-6, end_coordinate=6).tolist()
    faces = generate_faces_from_grid(res, res)

    # Create mesh and object
    wm_mesh = bpy.data.meshes.new("wm_mesh")
    wm_mesh.from_pydata(vertices, [], faces)
    wm_mesh.update()

    # Create object and collection
    wm_terrain = bpy.data.objects.new("wm_terrain", wm_mesh)
    terrain_collection = bpy.data.collections.new("terrain_collection")
    bpy.context.scene.collection.children.link(terrain_collection)
    terrain_collection.objects.link(wm_terrain)

    # Plot
    """
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(x, y, z, cmap='viridis', linewidth=0)
    ax.set_aspect('equal', adjustable='box')
    ax.set_title('3D Weierstrass-Mandelbrot Surface')
    plt.show()

    plt.imshow(z, cmap='gray', interpolation='lanczos')  # height map
    plt.colorbar()
    plt.show()
    """
